
---

# Контракт взаимодействия: Бэкенд ↔ Дата-сайентист  
**Проект**: Web-приложение для прогнозирования самовозгорания угля при открытом хранении  
**Дата**: 22 ноября 2025 г.  
**Стороны**:  
- Бэкенд-разработчик (Эд)  
- Дата-сайентист (Аня)  

## 1. Цель контракта  
Определить интерфейс, форматы данных и обязательства сторон для интеграции машинно-обучающейся модели прогнозирования риска самовозгорания угля в бэкенд-часть веб-приложения.

## 2. Обязанности дата-сайентиста

### 2.1. Обеспечение обученной модели  
Дата-сайентист предоставляет обученную модель машинного обучения в формате файла (например, `.joblib`), либо в виде Python-функции, которая:
- Не требует подключения к внешним ресурсам во время инференса.
- Не использует глобальные переменные.
- Не читает файлы из файловой системы напрямую (все данные поступают через аргументы функции).
- Сохраняется в директорию `ml/models/final_model.joblib`.

### 2.2. Реализация функции прогнозирования  
Дата-сайентист реализует и предоставляет файл `ml/predict.py`, содержащий **публичную функцию**:

```python
def predict_risk(pile_features: dict) -> dict:
    """
    Прогнозирует уровень риска самовозгорания для одного штабеля на 3 дня вперёд.

    Аргументы:
        pile_features (dict): Словарь с признаками штабеля на конкретную дату.
                              Формат описан в Приложении A.

    Возвращает:
        dict: Словарь с результатом прогноза. Формат описан в Приложении B.
    """
    ...
```

Функция **должна быть идемпотентной** и **выполняться менее чем за 50 мс** на одном штабеле.

### 2.3. Реализация скрипта обучения  
Дата-сайентист предоставляет файл `ml/train_model.py`, который:
- Загружает данные из файлов:
  - `supplies.csv` — информация о поступлении/отгрузке угля
  - `fires.csv` — подтверждённые случаи возгорания
  - `temperature.csv` — замеры температуры
  - `weather.csv` — исторические погодные данные
- Выполняет предобработку и генерацию признаков согласно разделу 4.2 ТЗ.
- Обучает модель и сохраняет её в `ml/models/final_model.joblib`.
- Сохраняет метрики качества в `ml/metrics.json` в формате:
  ```json
  {
    "precision": 0.35,
    "recall": 0.72,
    "f1_score": 0.47,
    "pr_auc": 0.58
  }
  ```
- Использует фиксированный `random_state` (например, 42) для воспроизводимости.
- Работает в окружении Python ≥ 3.12.

### 2.4. Документирование зависимостей  
Дата-сайентист предоставляет файл `ml/requirements.txt`, содержащий **только необходимые зависимости** для загрузки модели и выполнения `predict_risk`. Пример:
```
scikit-learn==1.5.2
pandas==2.2.3
numpy==1.26.4
```

### 2.5. Гарантии качества модели  
Модель должна удовлетворять следующим условиям на тестовой выборке (разделённой по временному признаку):
- **Recall ≥ 70%**: не менее 70% реальных возгораний должны быть предсказаны в окне `[D−3, D−1]`, где D — дата фактического возгорания.
- **Precision ≥ 30%**: не более 70% предсказаний высокого риска могут быть ложными.
- **PR-AUC ≥ 0.5**: подтверждается в `ml/metrics.json`.

## 3. Обязанности бэкенд-разработчика

### 3.1. Предоставление данных  
Бэкенд обеспечивает дата-сайентисту (в процессе разработки) или его функции `predict_risk` (в процессе инференса) **полный набор признаков** в формате, описанном в Приложении A.

### 3.2. Интеграция модели  
Бэкенд:
- Загружает модель при старте приложения один раз.
- Вызывает `predict_risk()` для всех актуальных штабелей при получении новых данных.
- Сохраняет результаты прогнозов в таблицу `Prediction` в БД.
- Обеспечивает совместимость с функцией `predict_risk`, даже если внутренняя структура модели изменится.

### 3.3. Изоляция  
Бэкенд гарантирует, что логика ML полностью изолирована в модуле `integrations/ml_model.py` и не влияет на стабильность остальной системы.

## 4. Приложения

### Приложение A: Формат входных признаков (`pile_features`)
```python
{
    "pile_id": int,                      # Уникальный ID штабеля
    "coal_type": str,                    # Код угля (из supplies.csv, поле "Наим. ЕТСНГ")
    "pile_formation_date": "2019-01-02", # Дата первой выгрузки на склад (из supplies.csv)
    "initial_volume_tonnes": 11984.1925, # Начальный объём угля, тн
    "days_in_storage": int,              # = (дата прогноза) - pile_formation_date
    "temperature_p": float,              # Последняя измеренная температура (°C)
    "temp_trend_7d": float,              # Наклон линейной регрессии за 7 дней
    "temp_avg_7d": float,                # Средняя температура за 7 дней
    "temp_max_7d": float,                # Максимальная температура за 7 дней
    "days_since_last_fire": int,         # Дней с последнего возгорания в этом штабеле (-1 если не было)
    "fire_history_count": int,           # Количество возгораний за последний год
    "weather_temp_avg": float,           # Средняя температура воздуха за день (°C)
    "weather_humidity": float,           # Влажность (%)
    "season": int,                       # 1=весна, 2=лето, 3=осень, 4=зима
    "month_sin": float,                  # sin(2π * month / 12)
    "month_cos": float                   # cos(2π * month / 12)
}
```
> Все значения числовые. Пропущенные замеры температуры заменяются на 0.0. Отсутствие истории возгораний кодируется как `-1`.

### Приложение B: Формат выходных данных (`predict_risk`)
```python
{
    "pile_id": int,
    "forecast_date": "2025-11-22",        # Дата, на которую сделан прогноз
    "risk_levels": {
        "day_1": "low",                   # "low", "medium", "high"
        "day_2": "medium",
        "day_3": "high"
    },
    "probabilities": {
        "day_1": 0.12,                    # float от 0.0 до 1.0
        "day_2": 0.45,
        "day_3": 0.81
    }
}
```
**Примечание**:  
Поле `coal_type` берётся **исключительно из `supplies.csv` (столбец "Наим. ЕТСНГ")**.  
Столбцы `"Груз"` (в `fires.csv`) и `"Марка"` (в `temperature.csv`) содержат ту же информацию, но могут быть неполными. Основной источник — `supplies.csv`.